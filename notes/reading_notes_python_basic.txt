Reading notes for book python basic by Magnus Lie Hetland

----------Chapter_1----------

* str and int are class
* repr is a function, it prints out what the original code looks like
  "Hello, \nworld!"---> 'Hello, \nworld!'
  on the other hand, str will print what human expect to read:
  ---> Hello,
       world!
* 长字符串：""" something """ 可包含反斜杠和引号
* 原始字符串： print(r'something') 不会对反斜杠做出处理，保持原样，不能以反斜杠结尾
* 默认使用UTF-8编码

**小结：
表达式结果为一个值
语句让计算机执行特定操作如修改变量等
新函数：
abs(num)
bytes(string, encoding[, errors]
cmath.sqrt(num)
float(object)
help([object])
input(prompt)
int(obj)
math.ceil(num)
math.floor(num)
pow(x,y[,z])
repr(obj)
round(num, [, ndigits])

----------Chapter_1----------

----------Chapter_2----------

*数据结构的基本概念：容器，主要为序列，映射，集合
*对序列的基本操作：索引，切片，相加，相乘，成员资格检查，迭代

*list('hello') --> ['h','e','l','l','o']
 ''.join(somelist) --> change back to string
*不能给不存在的元素赋值
*del: delete list elements, works on dictionary or variables too
*使用切片赋值，可将切片替换为长度与其不同的序列,可在不替换原有元素的情况下插入/删除元素
*列表方法:
append, clear 就地修改列表

copy:
a = [1, 2, 3]
b = a
修改b会改变a， 两者指向同一个列表
a = [1, 2, 3]
b = a.copy()
修改b不会改变a，b指向a副本

count:
计算指定的元素在列表中出现了多少次
somelist.count(element)

extend:
同时将多个值附加到列表末尾, 而拼接不改变原列表而是返回一个新列表
a.extend(b)

index:
在列表中查找指定值第一次出现的索引
somelist.index(ele)

insert:
somelist.insert(index, ele)

pop:
从列表中删除一个元素（末尾为最后一个元素），并返回这一元素
somelist.pop(index) --> somelist[index]

remove:
删除第一个为指定值的元素

reverse:
按相反的顺序排列列表中的元素

sort:
对列表就地排序,不返回新列表
函数sorted可用于任何序列，但总是返回一个列表
sort接受两个可选参数： key 和 reverse
可将key设置为一个用于排序的函数


*元组
只要将一些值用逗号分隔，就能自动创建一个元组
只有一个值，也必须在它后面加上逗号

----------Chapter_2----------

----------Chapter_3----------

标准序列操作（索引、切片、乘法、成员资格检查、长度、最小值和最
大值）都适用于字符串，但别忘了字符串是不可变的，因此所有的元素
赋值和切片赋值都是非法的

value:.2f 指定2位小数的浮点数

"{{ceci n'est pas une replacement field}}".format() -->
"{ceci n'est pas une replacement field}"
在最终结果中包含花括号

*替换字段
由如下部分组成，其中每个部分都是可选的。
-替换字段名:
>>> "{foo} {} {bar} {}".format(1, 2, bar=4, foo=3)
'3 1 4 2'
混合使用指定/不指定参数名称，后者按出现顺序
或者索引
>>> "{foo} {1} {bar} {0}".format(1, 2, bar=4, foo=3)
'3 2 4 1'
不能同时使用手工编号和自动编号

-转换标志：
--跟在叹号后面的单个字符。当前支持的字符包括 r (repr), s （表示 str)和 a （表示 ascii ）
--如果你指定了转换标志，将不使用对象本身的格式设置机制，而是使
用指定的函数将对象转换为字符串
--还可指定要转换的值是哪种类型,为此可在格式说明（即冒号后面）使用字符:
>>> "The number is {num:f}".format(num=42)
'The number is 42.000000'
--类型说明符:
b 将整数表示为二进制数
c 将整数解读为Unicode码点
d 将整数视为十进制数进行处理，这是整数默认使用的说明符
e 使用科学表示法来表示小数（用 e 来表示指数）
E 与 e 相同，但使用 E 来表示指数
f 将小数表示为定点数
F 与 f 相同，但对于特殊值（ nan 和 inf ），使用大写表示
g 自动在定点表示法和科学表示法之间做出选择。这是默认用于小数的说明符，但在默认情况下至少有1位小数
G 与 g 相同，但使用大写来表示指数和特殊值
n 与 g 相同，但插入随区域而异的数字分隔符
o 将整数表示为八进制数
s 保持字符串的格式不变，这是默认用于字符串的说明符
x 将整数表示为十六进制数并使用小写字母
X 与 x 相同，但使用大写字母
% 将数表示为百分比值（乘以100，按说明符 f 设置格式，再在后面加上%）

-宽度、精度和千位分隔符
--浮点数默认在小数点后面显示6位小数
--指定宽度(使用整数指定):
>>> "{num:10}".format(num=3)
'          3'
>>> "{name:10}".format(name="Bob")
'Bob          '

--精度也是使用整数指定的，但需要在它前面加上一个表示小数点的句点:
>>> "Pi day is {pi:.2f}".format(pi=pi)
同时指定宽度和精度:
>>> "{pi:10.2f}".format(pi=pi)

--千位分隔符:逗号
>>> 'One googol is {:,}'.format(10**100)

--符号、对齐和用 0 填充

*字符串方法
-center, ljust,rjust, zfill

-find 在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，
否则返回 -1. 可以指定起点终点 
(rfind, index, rindex, count, startswith, endswith)

-join/split:
>>> dirs = '', 'usr', 'bin', 'env'
>>> '/'.join(dirs)
'/usr/bin/env'

-lower:
返回字符串的小写版本 
title:
首字母大写
(islower, istitle, isupper, translate)
(capitalize, casefold, swapcase, title, upper)

-replace

-strip:
将字符串开头和末尾的空白（但不包括中间的空白）删除，并返回删除后的
结果

----------Chapter_3----------

----------Chapter_4----------

*字典是Python中唯一的内置映射(mapping)类型

*字典由键及其相应的值组成，这种键值对称为项（item）

*基本的字典操作
len(d) 返回字典 d 包含的项（键值对）数
d[k] 返回与键 k 相关联的值
d[k] = v 将值 v 关联到键 k
del d[k] 删除键为 k 的项
k in d 检查字典 d 是否包含键为 k 的项

*字符串格式使用字典
>>> phonebook = {'Beth': '9102', 'Alice': '2341', 'Cecil': '3258'}
>>> "Cecil's phone number is {Cecil}.".format_map(phonebook)
"Cecil's phone number is 3258."

*字典方法
-clear

-copy:
当替换副本中的值时，原件不受影响。然而，如果修改副本中的值
就地修改而不是替换），原件也将发生变化
为避免这种问题，一种办法是执行深复制 from copy import deepcopy

-fromkeys:
创建一个新字典，其中包含指定的键，且每个键对应的值都是 None

-get:
使用 get 来访问不存在的键时，没有引发异常，而是返回 None

-items:
返回一个包含所有字典项的列表，其中每个元素都为 (key, value) 的形式

-keys:
返回一个字典视图，其中包含指定字典中的键

-pop:
可用于获取与指定键相关联的值，并将该键值对从字典中删除

-setdefault:
指定的键不存在时， setdefault 返回指定的值并相应地更新字典。如果
指定的键存在，就返回其值，并保持字典不变

-update:
使用一个字典中的项来更新另一个字典

-values:
返回一个由字典中的值组成的字典视图

----------Chapter_4----------

----------Chapter_5----------

***条件语句

*自定义分隔符：
>>> print("I", "wish", "to", "register", "a", "complaint", sep="_")
I_wish_to_register_a_complaint

*星号赋值：
可使用星号运算符（ * ）来收集多余的值，这样无需确保值和变量的个数
相同
>>> a, b, *rest = [1, 2, 3, 4]
>>> rest
[3, 4]
赋值语句的右边可以是任何类型的序列，但带星号的变量最终包含的总是
一个列表

*布尔值
用作布尔表达式（如用作 if 语句中的条件）时，下面的值都将被解释器
视为假：
False
None
0
""
()
[]
{}

- 布尔值 True 和 False 属于类型 bool ，而 bool 与 list 、 str 和
tuple 一样，可用来转换其他的值-->True False

*比较运算符
x is y： x 和 y 是同一个对象
is 检查两个对象是否相同（而不是相等）
不要将 is 用于数和字符串等不可变的基本值

*字符串比较
字符串是根据字符的字母排列顺序进行比较的
字母都是Unicode字符，它们是按码点排列的
要获悉字母的顺序值，可使用函数 ord
与函数ord相反的是chr

*assert
要求某些条件得到满足再运行程序


***循环
*while 语句非常灵活，可用于在条件为真时反复执行代码块:
while condition:
    do something
*for 循环
为序列（或其他可迭代对象）中每个元素执行代码块
-range（）包含起始位置但不包含结束位置

*一些迭代工具
-并行迭代
内置函数 zip ，它将两个序列“缝合”起来，并返回一个由元组组成
的序列（对象）序列的长度不同时，函数 zip 将在最短的序列用完
后停止“缝合”

-迭代时获取索引
for index, string in enumerate(strings):
    ....
-反向迭代和排序后再迭代
函数sorted 返回一个列表，而 reversed 像 zip 那样返回一个更神秘的可
迭代对象

*跳出循环
-break

-continue
结束当前迭代，并跳到下一次迭代开头。这基本上意味着跳过循环体中余
下的语句，但不结束循环

-while True/break

-else子句
有时候你可能想在循环正常结束时才采取某种措施：
for n in seq:
    if condition:
        do something
        break
else:
    do something # 某种措施

*列表推导:
一种从其他列表创建列表的方式，类似于数学中的集合推导

*三人行

-pass

-del 删除一个名称

-exec:
函数 exec 将字符串作为代码执行。危险！！
>>> exec("print('Hello, world!')")
Hello, world!
只给它提供一个参数绝非好事。在大多数情况下，还应向它传递一个
命名空间：
>>>scope = {}
>>>exec('sqrt = 1', scope)
>>>scope['sqrt']
1

-eval:
eval 是一个类似于 exec 的内置函数。 exec 执行一系列Python语句，
而 eval 计算用字符串表示的Python表达式的值，并返回结果
（ exec 什么都不返回，因为它本身是条语句）
与 exec 一样，也可向 eval 提供一个命名空间

----------Chapter_5----------

----------Chapter_6----------

*自定义函数
函数执行特定的操作并返回一个值, 可以调用它, 要判断某个对象是否
可调用，可使用内置函数 callable

*给函数编写文档:
放在函数开头的字符串称为文档字符串（docstring）
访问文档字符串 func.__doc__
双下划线表示特殊的属性

*return
你在 if 之类的语句中返回值，务必确保其他分支也返回值，
以免在调用者期望函数返回一个序列时（举个例子），
不小心返回了 None

*函数名后面的变量通常称为形参，而调用函数时提供的值称为实参

*函数内赋值：
将同一个列表赋给两个变量时，这两个变量将同时指向这个列表，对其中
一个变量重新赋值（如函数内）将同时改变另一个变量指向的列表（原列
表）
如何避免：
创建列表的副本，对序列执行切片操作都会返回副本

*要改变函数外部的变量，只能修改参数对象本身

*使用名称指定的参数称为关键字参数
def hello_1(greeting, name):
print('{}, {}!'.format(greeting, name))
>>> hello_1(greeting='Hello', name='world')
Hello, world!

*收集参数
允许用户提供任意数量的参数
def print_params(*params):
    print(params)
参数前面的星号将提供的所有值都放在一个元组中，也就是将这些值收
集起来

-要收集关键字参数，可使用两个星号
>>> def print_params_3(**params):
...
print(params)
...
>>> print_params_3(x=1, y=2, z=3)
{'z': 3, 'x': 1, 'y': 2}

*命名空间或作用域
除全局作用域外，每个函数调用都将创建一个
函数内访问全局变量是bug根源，务必慎用全局变量
必要时可使用 globals()['parameter']

*作用域嵌套
使用一个函数来创建另一个函数，外面的函数返回里面的函数，
包括作用域，而不是调用它，存储其所在作用域的函数称为闭包

*递归
递归函数通常包含下面两部分：
基线条件（针对最小的问题）：满足这种条件时函数将直接返回一个值
递归条件：包含一个或多个调用，这些调用旨在解决问题的一部分

----------Chapter_6----------

----------Chapter_7----------

***面向对象编程***

*术语对象大致意味着一系列数据（属性）以及一套访问和操作
这些数据的方法。使用对象的好处
-多态：可对不同类型的对象执行相同的操作，而这些操作就像
“被施了魔法”一样能够正常运行。
-封装：对外部隐藏有关对象工作原理的细节
-继承：可基于通用类创建出专用类。


°__repr__ 对象原来的样子
__str__用户可读

*封装
属性是归属于对象的变量，就像方法一样
对象有自己的状态。对象的状态由其属性（如名称）描述

*类
单数并将首字母大写，如 Bird 和 Lark
“云雀”为“鸟类”的子类，而“鸟类”为“云雀”的超类
类是由其支持的方法定义的

-属性、函数和方法
--方法将其第一个参数关联到它所属的实例，
因此无需提供这个参数

--要让方法或属性成为私有的（不能从外部访问）
，
只需让其名称以两个下划线打头即可
from module import * 不会导入以一个下划线打头的名称

--类定义其实就是要执行的代码段

--要确定一个类是否是另一个类的子类，可使用内置方法 issubclass

--如果你有一个类，并想知道它的基类，可访问其特殊属性 __bases__
 
--要确定对象是否是特定类的实例，可使用 isinstance

--接口和内省
对外暴露的方法和属性
hasattr getattr setattr

*抽象基类
显式指定接口的理念
模块 abc 提供了官方解决方案。这个模块为所谓的抽象基类提供了支持
抽象类是不能（至少是不应该）实例化的类，其职责是定义子类应实现的一组抽象方法
from abc import ABC, abstractmethod
class Talker(ABC):
    @abstractmethod
    def talk(self):
        pass
@this: decorator

-->抽象类(a)不能实例化
-->重写method（b）能让派生类实例化
-->如果一个实例(c）是抽象类a子类对象，就能相信这个实例c有方法b

---->d import from other modul
---->a.register(d)
把d注册为a，所有d对象都视为a对象，但是从抽象类派生的保障就没有了

换而言之，应将 isinstance 返回 True 视为一种意图表达。
在这里， d 有成为a 的意图。
本着鸭子类型的精神，我们相信它能承担a 的职责，但可悲的是它失败了。

***小结***
对象：对象由属性和方法组成。属性不过是属于对象的变量，而方法是
存储在属性中的函数。相比其他函数，（关联的）方法有一个不同之处，
那就是它总是将其所属的对象作为第一个参数，而这个参数通常
被命名为 self

类：类表示一组（或一类）对象，而每个对象都属于特定的类。
类的主要任务是定义其实例将包含的方法

多态：多态指的是能够同样地对待不同类型和类的对象，即无需知道对象
属于哪个类就可调用其方法

封装：对象可能隐藏（封装）其内部状态。在有些语言中，这意味着对象
的状态（属性）只能通过其方法来访问。在Python中，所有的属性都是
公有的，但直接访问对象的状态时程序员应谨慎行事，因为这可能在
不经意间导致状态不一致

抽象基类：使用模块 abc 可创建抽象基类。抽象基类用于指定子类必须
提供哪些功能，却不实现这些功能

----------Chapter_7----------

----------Chapter_8----------

*raise 语句
每个异常都是某个类
要引发异常，可使用 raise 语句，并将一个类（必须是 Exception
的子类）或实例作为参数
一些内置的异常类
Exception 几乎所有的异常类都是从它派生而来的
AttributeError 引用属性或给它赋值失败时引发
OSError 操作系统不能执行指定的任务（如打开文件）时引发，有多个子类
IndexError 使用序列中不存在的索引时引发，为 LookupError 的子类
KeyError 使用映射中不存在的键时引发，为 LookupError 的子类
NameError 找不到名称（变量）时引发
SyntaxError 代码不正确时引发
TypeError 将内置操作或函数用于类型不正确的对象时引发
ValueError 将内置操作或函数用于这样的对象时引发：其类型正确但包含的值不合适
ZeroDivisionError 在除法或求模运算的第二个参数为零时引发

*捕获异常
try / except
关闭抑制功能时，捕获了异常 ZeroDivisionError ，但继续向上传播它（rasie）
有时你可能想引发别的异常。在这种情况下，导致进入 except 子句
的异常将被作为异常上下文存储起来，并出现在最终的错误消息中
可使用 raise ... from ... 语句来提供自己的异常上下文，
也可使用 None 来禁用上下文

在 except 子句中，异常两边的圆括号很重要。一种常见的错误是省
略这些括号，这可能导致你不想要的结果

更好的选择是使用 except Exception as e 并对异常对象进行检查

*最后
还有 finally 子句，可用于在发生异常时执行清理工作。这个子句是与
try 子句配套的
x = None
try:
    x = 1 / 0
finally:
    print('Cleaning up ...')
    del x
在上述示例中，不管 try 子句中发生什么异常，都将执行 finally 子句

检查对象是否包含特定的属性时， try / except 也很有用

在很多情况下，相比于使用 if / else ，使用try / except 语句更
自然，也更符合Python的风格。因此你应养成尽可能使用 try / except 
语句的习惯

警告：警告类似于异常，但（通常）只打印一条错误消息。你可指
定警告类别，它们是Warning 的子类

----------Chapter_8----------

----------Chapter_9----------

特性（property）和迭代器（iterator）

*构造函数（constructor）
__init__
构造函数不同于普
通方法的地方在于，将在对象创建后自动调用它们
重写是继承机制的一个重要方面，对构造函数来说尤其重要
-重写构造函数时，必须调用超类（继承的类）的构造函数
--调用未关联的超类构造函数
在子类构造函数中添加：超类.__init__(self)
--使用函数 super
在子类构造函数中添加:super().__init__()

*元素访问
在Python中，协议通常指的是规范行为的规则,协议指定
应实现哪些方法以及这些方法应做什么，多态仅仅基于对象的行为
（而不基于祖先，如属于哪个类或其超类等）因此这个概念很重要：
其他的语言可能要求对象属于特定的类或实现了特定的接口，
而Python通常只要求对象遵循特定的协议。因此，要成为序列，
只需遵循序列协议即可




