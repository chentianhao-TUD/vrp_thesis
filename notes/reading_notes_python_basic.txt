Reading notes for book python basic by Magnus Lie Hetland

----------Chapter_1----------

* str and int are class
* repr is a function, it prints out what the original code looks like
  "Hello, \nworld!"---> 'Hello, \nworld!'
  on the other hand, str will print what human expect to read:
  ---> Hello,
       world!
* 长字符串：""" something """ 可包含反斜杠和引号
* 原始字符串： print(r'something') 不会对反斜杠做出处理，保持原样，不能以反斜杠结尾
* 默认使用UTF-8编码

**小结：
表达式结果为一个值
语句让计算机执行特定操作如修改变量等
新函数：
abs(num)
bytes(string, encoding[, errors]
cmath.sqrt(num)
float(object)
help([object])
input(prompt)
int(obj)
math.ceil(num)
math.floor(num)
pow(x,y[,z])
repr(obj)
round(num, [, ndigits])

----------Chapter_1----------

----------Chapter_2----------

*数据结构的基本概念：容器，主要为序列，映射，集合
*对序列的基本操作：索引，切片，相加，相乘，成员资格检查，迭代

*list('hello') --> ['h','e','l','l','o']
 ''.join(somelist) --> change back to string
*不能给不存在的元素赋值
*del: delete list elements, works on dictionary or variables too
*使用切片赋值，可将切片替换为长度与其不同的序列,可在不替换原有元素的情况下插入/删除元素
*列表方法:
append, clear 就地修改列表

copy:
a = [1, 2, 3]
b = a
修改b会改变a， 两者指向同一个列表
a = [1, 2, 3]
b = a.copy()
修改b不会改变a，b指向a副本

count:
计算指定的元素在列表中出现了多少次
somelist.count(element)

extend:
同时将多个值附加到列表末尾, 而拼接不改变原列表而是返回一个新列表
a.extend(b)

index:
在列表中查找指定值第一次出现的索引
somelist.index(ele)

insert:
somelist.insert(index, ele)

pop:
从列表中删除一个元素（末尾为最后一个元素），并返回这一元素
somelist.pop(index) --> somelist[index]

remove:
删除第一个为指定值的元素

reverse:
按相反的顺序排列列表中的元素

sort:
对列表就地排序,不返回新列表
函数sorted可用于任何序列，但总是返回一个列表
sort接受两个可选参数： key 和 reverse
可将key设置为一个用于排序的函数


*元组
只要将一些值用逗号分隔，就能自动创建一个元组
只有一个值，也必须在它后面加上逗号

----------Chapter_2----------

----------Chapter_3----------

标准序列操作（索引、切片、乘法、成员资格检查、长度、最小值和最
大值）都适用于字符串，但别忘了字符串是不可变的，因此所有的元素
赋值和切片赋值都是非法的

value:.2f 指定2位小数的浮点数

"{{ceci n'est pas une replacement field}}".format() -->
"{ceci n'est pas une replacement field}"
在最终结果中包含花括号

*替换字段
由如下部分组成，其中每个部分都是可选的。
-替换字段名:
>>> "{foo} {} {bar} {}".format(1, 2, bar=4, foo=3)
'3 1 4 2'
混合使用指定/不指定参数名称，后者按出现顺序
或者索引
>>> "{foo} {1} {bar} {0}".format(1, 2, bar=4, foo=3)
'3 2 4 1'
不能同时使用手工编号和自动编号

-转换标志：
--跟在叹号后面的单个字符。当前支持的字符包括 r (repr), s （表示 str)和 a （表示 ascii ）
--如果你指定了转换标志，将不使用对象本身的格式设置机制，而是使
用指定的函数将对象转换为字符串
--还可指定要转换的值是哪种类型,为此可在格式说明（即冒号后面）使用字符:
>>> "The number is {num:f}".format(num=42)
'The number is 42.000000'
--类型说明符:
b 将整数表示为二进制数
c 将整数解读为Unicode码点
d 将整数视为十进制数进行处理，这是整数默认使用的说明符
e 使用科学表示法来表示小数（用 e 来表示指数）
E 与 e 相同，但使用 E 来表示指数
f 将小数表示为定点数
F 与 f 相同，但对于特殊值（ nan 和 inf ），使用大写表示
g 自动在定点表示法和科学表示法之间做出选择。这是默认用于小数的说明符，但在默认情况下至少有1位小数
G 与 g 相同，但使用大写来表示指数和特殊值
n 与 g 相同，但插入随区域而异的数字分隔符
o 将整数表示为八进制数
s 保持字符串的格式不变，这是默认用于字符串的说明符
x 将整数表示为十六进制数并使用小写字母
X 与 x 相同，但使用大写字母
% 将数表示为百分比值（乘以100，按说明符 f 设置格式，再在后面加上%）

-宽度、精度和千位分隔符
--浮点数默认在小数点后面显示6位小数
--指定宽度(使用整数指定):
>>> "{num:10}".format(num=3)
'          3'
>>> "{name:10}".format(name="Bob")
'Bob          '

--精度也是使用整数指定的，但需要在它前面加上一个表示小数点的句点:
>>> "Pi day is {pi:.2f}".format(pi=pi)
同时指定宽度和精度:
>>> "{pi:10.2f}".format(pi=pi)

--千位分隔符:逗号
>>> 'One googol is {:,}'.format(10**100)

--符号、对齐和用 0 填充

*字符串方法
-center, ljust,rjust, zfill

-find 在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，
否则返回 -1. 可以指定起点终点 
(rfind, index, rindex, count, startswith, endswith)

-join/split:
>>> dirs = '', 'usr', 'bin', 'env'
>>> '/'.join(dirs)
'/usr/bin/env'

-lower:
返回字符串的小写版本 
title:
首字母大写
(islower, istitle, isupper, translate)
(capitalize, casefold, swapcase, title, upper)

-replace

-strip:
将字符串开头和末尾的空白（但不包括中间的空白）删除，并返回删除后的
结果

----------Chapter_3----------

----------Chapter_4----------

*字典是Python中唯一的内置映射(mapping)类型

*字典由键及其相应的值组成，这种键值对称为项（item）

*基本的字典操作
len(d) 返回字典 d 包含的项（键值对）数
d[k] 返回与键 k 相关联的值
d[k] = v 将值 v 关联到键 k
del d[k] 删除键为 k 的项
k in d 检查字典 d 是否包含键为 k 的项

*字符串格式使用字典
>>> phonebook = {'Beth': '9102', 'Alice': '2341', 'Cecil': '3258'}
>>> "Cecil's phone number is {Cecil}.".format_map(phonebook)
"Cecil's phone number is 3258."

*字典方法
-clear

-copy:
当替换副本中的值时，原件不受影响。然而，如果修改副本中的值
就地修改而不是替换），原件也将发生变化
为避免这种问题，一种办法是执行深复制 from copy import deepcopy

-fromkeys:
创建一个新字典，其中包含指定的键，且每个键对应的值都是 None

-get:
使用 get 来访问不存在的键时，没有引发异常，而是返回 None

-items:
返回一个包含所有字典项的列表，其中每个元素都为 (key, value) 的形式

-keys:
返回一个字典视图，其中包含指定字典中的键

-pop:
可用于获取与指定键相关联的值，并将该键值对从字典中删除

-setdefault:
指定的键不存在时， setdefault 返回指定的值并相应地更新字典。如果
指定的键存在，就返回其值，并保持字典不变

-update:
使用一个字典中的项来更新另一个字典

-values:
返回一个由字典中的值组成的字典视图

----------Chapter_4----------

----------Chapter_5----------

***条件语句

*自定义分隔符：
>>> print("I", "wish", "to", "register", "a", "complaint", sep="_")
I_wish_to_register_a_complaint

*星号赋值：
可使用星号运算符（ * ）来收集多余的值，这样无需确保值和变量的个数
相同
>>> a, b, *rest = [1, 2, 3, 4]
>>> rest
[3, 4]
赋值语句的右边可以是任何类型的序列，但带星号的变量最终包含的总是
一个列表

*布尔值
用作布尔表达式（如用作 if 语句中的条件）时，下面的值都将被解释器
视为假：
False
None
0
""
()
[]
{}

- 布尔值 True 和 False 属于类型 bool ，而 bool 与 list 、 str 和
tuple 一样，可用来转换其他的值-->True False

*比较运算符
x is y： x 和 y 是同一个对象
is 检查两个对象是否相同（而不是相等）
不要将 is 用于数和字符串等不可变的基本值

*字符串比较
字符串是根据字符的字母排列顺序进行比较的
字母都是Unicode字符，它们是按码点排列的
要获悉字母的顺序值，可使用函数 ord
与函数ord相反的是chr

*assert
要求某些条件得到满足再运行程序


***循环
*while 语句非常灵活，可用于在条件为真时反复执行代码块:
while condition:
    do something
*for 循环
为序列（或其他可迭代对象）中每个元素执行代码块
-range（）包含起始位置但不包含结束位置

*一些迭代工具
-并行迭代
内置函数 zip ，它将两个序列“缝合”起来，并返回一个由元组组成
的序列（对象）序列的长度不同时，函数 zip 将在最短的序列用完
后停止“缝合”

-迭代时获取索引
for index, string in enumerate(strings):
    ....
-反向迭代和排序后再迭代
函数sorted 返回一个列表，而 reversed 像 zip 那样返回一个更神秘的可
迭代对象

*跳出循环
-break

-continue
结束当前迭代，并跳到下一次迭代开头。这基本上意味着跳过循环体中余
下的语句，但不结束循环

-while True/break

-else子句
有时候你可能想在循环正常结束时才采取某种措施：
for n in seq:
    if condition:
        do something
        break
else:
    do something # 某种措施

*列表推导:
一种从其他列表创建列表的方式，类似于数学中的集合推导

*三人行

-pass

-del 删除一个名称

-exec:
函数 exec 将字符串作为代码执行。危险！！
>>> exec("print('Hello, world!')")
Hello, world!
只给它提供一个参数绝非好事。在大多数情况下，还应向它传递一个
命名空间：
>>>scope = {}
>>>exec('sqrt = 1', scope)
>>>scope['sqrt']
1

-eval:
eval 是一个类似于 exec 的内置函数。 exec 执行一系列Python语句，
而 eval 计算用字符串表示的Python表达式的值，并返回结果
（ exec 什么都不返回，因为它本身是条语句）
与 exec 一样，也可向 eval 提供一个命名空间

----------Chapter_5----------

----------Chapter_6----------

*自定义函数
函数执行特定的操作并返回一个值, 可以调用它, 要判断某个对象是否
可调用，可使用内置函数 callable

*给函数编写文档:
放在函数开头的字符串称为文档字符串（docstring）
访问文档字符串 func.__doc__
双下划线表示特殊的属性

*return
你在 if 之类的语句中返回值，务必确保其他分支也返回值，
以免在调用者期望函数返回一个序列时（举个例子），
不小心返回了 None

*函数名后面的变量通常称为形参，而调用函数时提供的值称为实参

*函数内赋值：
将同一个列表赋给两个变量时，这两个变量将同时指向这个列表，对其中
一个变量重新赋值（如函数内）将同时改变另一个变量指向的列表（原列
表）
如何避免：
创建列表的副本，对序列执行切片操作都会返回副本

